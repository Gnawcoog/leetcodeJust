# 1. 二叉树遍历
[ :fa-star: 基础要点](https://zhuanlan.zhihu.com/p/168264121)

- 树
> **节点：节点的度、节点关系、节点层次、树的深度** 

- 二叉树
> :fa-arrow-right: **满二叉树**   
> :fa-arrow-right: **完全二叉树** ：满二叉树一定是完全二叉树，反之不一定成立  
> :fa-arrow-right: 二叉树的存储结构：链式存储、顺序存储  
> :fa-arrow-right: 二叉树的遍历方式:深度优先遍历【前序遍历（递归法，迭代法）、中序遍历（递归法，迭代法）、后序遍历（递归法，迭代法）】、广度优先遍历【层次遍历（迭代法）】

```c++
// 链式存储
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};
```

- 二叉树的递归遍历
> 递归三要素： _**确定递归函数的参数和返回值、确定终止条件、确定单层递归的逻辑**_ 

```c++
// 前序遍历
class Solution {
public:
    void traversal(TreeNode* cur, vector<int>& vec) {
        if (cur == NULL) return;
        vec.push_back(cur->val);    // 中
        traversal(cur->left, vec);  // 左
        traversal(cur->right, vec); // 右
    }
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> result;
        traversal(root, result);
        return result;
    }
};


// 中序遍历
void traversal(TreeNode* cur, vector<int>& vec) {
    if (cur == NULL) return;
    traversal(cur->left, vec);  // 左
    vec.push_back(cur->val);    // 中
    traversal(cur->right, vec); // 右
}
// 后序遍历
void traversal(TreeNode* cur, vector<int>& vec) {
    if (cur == NULL) return;
    traversal(cur->left, vec);  // 左
    traversal(cur->right, vec); // 右
    vec.push_back(cur->val);    // 中
}
```

- 二叉树的迭代遍历
> 前序遍历是中左右，每次先处理的是中间节点，那么先将根节点放入栈中，然后将右孩子加入栈，再加入左孩子  

```c++
// 前序遍历
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        stack<TreeNode*> st;
        vector<int> result;
        if (root == NULL) return result;
        st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();                       // 中
            st.pop();
            result.push_back(node->val);
            if (node->right) st.push(node->right);           // 右（空节点不入栈）
            if (node->left) st.push(node->left);             // 左（空节点不入栈）
        }
        return result;
    }
};
```

> 使用迭代法写中序遍历，需要借用指针的遍历来帮助访问节点，栈用来处理节点上的元素

```c++
// 中序遍历
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<TreeNode*> st;
        TreeNode* cur = root;
        while (cur != NULL || !st.empty()) {
            if (cur != NULL) { // 指针来访问节点，访问到最底层
                st.push(cur); // 将访问的节点放进栈
                cur = cur->left;                // 左
            } else {
                cur = st.top(); // 从栈里弹出的数据，就是要处理的数据（放进result数组里的数据）
                st.pop();
                result.push_back(cur->val);     // 中
                cur = cur->right;               // 右
            }
        }
        return result;
    }
};
```

> 后序遍历只需要前序遍历的代码稍作修改就可以

```c++
// 后序遍历
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        stack<TreeNode*> st;
        vector<int> result;
        if (root == NULL) return result;
        st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();
            st.pop();
            result.push_back(node->val);
            if (node->left) st.push(node->left); // 相对于前序遍历，这更改一下入栈顺序 （空节点不入栈）
            if (node->right) st.push(node->right); // 空节点不入栈
        }
        reverse(result.begin(), result.end()); // 将结果反转之后就是左右中的顺序了
        return result;
    }
};
```

- 二叉树的层序遍历  
> 这份代码可以作为二叉树层序遍历的模板

```c++
// 层序遍历
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        queue<TreeNode*> que; //辅助队列
        if (root != NULL) que.push(root); //存根节点
        vector<vector<int>> result; //用于结果输出
        while (!que.empty()) {
            int size = que.size(); //自动确定层中节点数量
            vector<int> vec; //存放每层输出结果
            // 输出每层结果的同时更新下一层层中节点数量
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front(); //暂存
                que.pop(); //弹出
                vec.push_back(node->val); //利用暂存写入结果
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
            result.push_back(vec); //将单层结果存入总结果
        }
        return result;
    }
};
```


#### 107、二叉树的层序遍历 II
> 给你二叉树的根节点 root ，返回其节点值 自底向上的层序遍历 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）

#### 199、二叉树的右视图
> 给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

#### 637、二叉树的层平均值
> 给定一个非空二叉树的根节点 root , 以数组的形式返回每一层节点的平均值。与实际答案相差 10-5 以内的答案可以被接受。

#### 429、N 叉树的层序遍历
> 给定一个 N 叉树，返回其节点值的层序遍历。（即从左到右，逐层遍历）。树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。

#### 515. 在每个树行中找最大值
> 给定一棵二叉树的根节点 root ，请找出该二叉树中每一层的最大值。

#### 116. 填充每个节点的下一个右侧节点指针
> 给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下： 
 
```c++
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}  
```
> 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。初始状态下，所有 next 指针都被设置为 NULL。

#### 117. 填充每个节点的下一个右侧节点指针 II
> 给定一个二叉树：

```c++
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
```

> 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL 。初始状态下，所有 next 指针都被设置为 NULL 。

#### 104. 二叉树的最大深度
> 给定一个二叉树 root ，返回其最大深度。二叉树的 最大深度 是指从根节点到最远叶子节点的最长路径上的节点数。

#### 111. 二叉树的最小深度
> 给定一个二叉树，找出其最小深度。最小深度是从根节点到最近叶子节点的最短路径上的节点数量。说明：叶子节点是指没有子节点的节点。

 
# 2. 翻转二叉树
 :fa-star: 只要把每一个节点的左右孩子翻转一下，就可以达到整体翻转的效果。  
 :fa-star: 在实际项目开发的过程中要尽量避免递归！因为项目代码参数、调用关系都比较复杂，不容易控制递归深度，甚至会栈溢出。  
 :fa-star: 一定要掌握前中后序一种迭代的写法，并不因为某种场景的题目一定要用迭代，而是现场面试的时候，面试官看你顺畅的写出了递归，一般会进一步考察能不能写出相应的迭代。

#### 226、翻转二叉树
> 给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。


# 3. 对称二叉树
 :fa-star: 把左右两个子树要比较的元素顺序放进一个容器，然后成对成对的取出来进行比较。  
 :fa-star: 对称性递归： _对一个对称的数据结构（二叉树）从整体的对称性思考，把大问题分解成子问题进行递归，即不是单独考虑一部分(比如树的左子树)，而是同时考虑对称的两部分(左右子树)，从而写出对称性的递归代码。_  
> 可以用对称性递归解决的二叉树问题大多是判断性问题(bool类型函数)：  
> 1、不需要构造辅助函数。第一种是 **单树问题** ，且不需要用到子树的某一部分(比如根节点左子树的右子树)，只要利用根节点左右子树的对称性即可进行递归。第二种是 **双树问题** ，即本身题目要求比较两棵树，那么不需要构造新函数。  
> 2、需要构造辅助函数。这类题目通常只用根节点子树对称性无法完全解决问题，必须要用到子树的某一部分进行递归，即要调用辅助函数比较两个部分子树。形式上主函数参数列表只有一个根节点，辅助函数参数列表有两个节点。

```c++
 // 解题模板 

//递归结束条件：如果是单树问题，一般来说只要进行以下判断：
if(!root) return true/false;
if(!root->left) return true/false/递归函数;
if(!root->right) return true/false/递归函数;
//如果是双树问题(根节点分别为p,q)，一般来说进行以下判断：
if(!p && !q)return true/false;
if(!p || !q)return true/false;

//返回值通常是多个条件的复合判断语句 可能是以下几种条件判断的组合： 
//1.节点非空的判断 
//2.节点值比较判断 
//3.(单树)调用根节点左右子树的递归函数进行递归判断 
//4.(双树)调用两棵树的左右子树的递归函数进行判断
```

#### 101、对称二叉树
> 给你一个二叉树的根节点 root ， 检查它是否轴对称。

#### 100、相同的树
> 给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。

#### 572、另一棵树的子树
> 给你两棵二叉树 root 和 subRoot 。检验 root 中是否包含和 subRoot 具有相同结构和节点值的子树。如果存在，返回 true ；否则，返回 false 。二叉树 tree 的一棵子树包括 tree 的某个节点和这个节点的所有后代节点。tree 也可以看做它自身的一棵子树。
 

# 4. 完全二叉树的节点个数
 :fa-star: 只要模板少做改动，加一个变量result，统计节点数量。

#### 222、完全二叉树的节点个数
> 给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。


# 5. 平衡二叉树
 :fa-star: 求深度适合用前序遍历，而求高度适合用后序遍历。

#### 110、平衡二叉树
> 给定一个二叉树，判断它是否是高度平衡的二叉树。本题中，一棵高度平衡二叉树定义为：一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。


# 6. 二叉树的所有路径
 :fa-star: 要求从根节点到叶子的路径，所以需要前序遍历，这样才方便让父节点指向孩子节点，找到对应的路径。  
 :fa-star: 回溯和递归是一一对应的，有一个递归，就要有一个回溯。

#### 257、二叉树的所有路径
> 给你一个二叉树的根节点 root ，按 任意顺序 ，返回所有从根节点到叶子节点的路径。叶子节点 是指没有子节点的节点


# 7.左叶子之和
 :fa-star: 判断当前节点是不是左叶子是无法判断的，必须要通过节点的父节点来判断其左孩子是不是左叶子。
> 该节点的左节点不为空，该节点的左节点的左节点为空，该节点的左节点的右节点为空，则找到了一个左叶子。

```c++
if (node->left != NULL && node->left->left == NULL && node->left->right == NULL) {
    左叶子节点处理逻辑
}
```
 :fa-star: 递归的遍历顺序为后序遍历（左右中），是因为要通过递归函数的返回值来累加求取左叶子数值之和。

#### 404、左叶子之和
> 给定二叉树的根节点 root ，返回所有左叶子之和。


# 8. 找树左下角的值
 :fa-star: 用层序遍历是非常简单的。

#### 513、找树左下角的值
> 给定一个二叉树的 根节点 root，请找出该二叉树的 最底层 最左边 节点的值。假设二叉树中至少有一个节点。

 
# 9. 路径总和
 :fa-star: 前中后序都可以，因为中节点也没有处理逻辑

#### 112、路径总和
> 给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。叶子节点 是指没有子节点的节点。

#### 113. 路径总和 II
> 给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。叶子节点 是指没有子节点的节点。


# 10. 从中序与后序遍历序列构造二叉树
 :fa-star: 切割。

#### 106、从中序与后序遍历序列构造二叉树
> 给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。

#### 105、从前序与中序遍历序列构造二叉树
> 给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。

 
# 11. 最大二叉树
 :fa-star: 构造树一般采用的是前序遍历，因为先构造中间节点，然后递归构造左子树和右子树。

#### 654、最大二叉树
> 给定一个不重复的整数数组 nums 。 最大二叉树 可以用下面的算法从 nums 递归地构建:  
> 1.创建一个根节点，其值为 nums 中的最大值。  
> 2.递归地在最大值 左边 的 子数组前缀上 构建左子树。  
> 3.递归地在最大值 右边 的 子数组后缀上 构建右子树。  
> 返回 nums 构建的 最大二叉树 。

 
# 12. 合并二叉树
 :fa-star: 同时遍历两个二叉树和遍历一个树逻辑是一样的，只不过传入两个树的节点，同时操作。

#### 617、合并二叉树
> 给你两棵二叉树： root1 和 root2 。想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。返回合并后的二叉树。注意: 合并过程必须从两个树的根节点开始。

 
# 13. 二叉搜索树中的搜索
 :fa-star: 二叉搜索树是一个有序树：若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；它的左、右子树也分别为二叉搜索树。

#### 700、二叉搜索树中的搜索
> 给定二叉搜索树（BST）的根节点 root 和一个整数值 val。你需要在 BST 中找到节点值等于 val 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 null 。


# 14. 验证二叉搜索树
 :fa-star: 中序遍历下，输出的二叉搜索树节点的数值是有序序列。
 :fa-star: 验证二叉搜索树，就相当于变成了判断一个序列是不是递增的了。

#### 98、验证二叉搜索树
> 给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。有效 二叉搜索树定义如下：  
> 节点的左子树只包含 小于 当前节点的数。  
> 节点的右子树只包含 大于 当前节点的数。  
> 所有左子树和右子树自身必须也是二叉搜索树。  
 

# 15. 二叉搜索树的最小绝对差
 :fa-star: 遇到在二叉搜索树上求什么最值啊，差值之类的，就把它想成在一个有序数组上求最值，求差值，这样就简单多了。

#### 530、二叉搜索树的最小绝对差
> 给你一个二叉搜索树的根节点 root ，返回 树中任意两不同节点值之间的最小差值 。差值是一个正数，其数值等于两值之差的绝对值。


# 16. 二叉搜索树中的众数
 :fa-star:  _两次遍历_ ：先遍历一遍数组，找出最大频率（maxCount），然后再重新遍历一遍数组把出现频率为maxCount的元素放进集合（因为众数有多个）。  
 :fa-star:  _一次遍历_ ：如果 频率count 等于 maxCount（最大频率），当然要把这个元素加入到结果集中，频率count 大于 maxCount的时候，不仅要更新maxCount，而且要清空结果集，因为结果集之前的元素都失效了。

#### 501. 二叉搜索树中的众数
> 给你一个含重复值的二叉搜索树（BST）的根节点 root ，找出并返回 BST 中的所有 众数（即，出现频率最高的元素）。如果树中有不止一个众数，可以按 任意顺序 返回。  
> 假定 BST 满足如下定义：  
> 结点左子树中所含节点的值 小于等于 当前节点的值  
> 结点右子树中所含节点的值 大于等于 当前节点的值  
> 左子树和右子树都是二叉搜索树  


# 17. 二叉树的最近公共祖先
 :fa-star: 递归函数有返回值就是要遍历某一条边。

```c++
// 搜索一条边的写法：
if (递归函数(root->left)) return ;

if (递归函数(root->right)) return ;

// 搜索整个树写法：
left = 递归函数(root->left);  // 左
right = 递归函数(root->right); // 右
left与right的逻辑处理;         // 中 
```
 :fa-star: 在递归函数有返回值的情况下：如果要搜索一条边，递归函数返回值不为空的时候，立刻返回，如果搜索整个树，直接用变量left、right接住返回值，这个left、right后序还有逻辑处理的需要，也就是后序遍历中处理中间节点的逻辑（也是回溯）。

#### 236、二叉树的最近公共祖先
> 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。  
> 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”


# 18. 二叉搜索树的最近公共祖先
 :fa-star: 因为是有序树，所有 如果 中间节点是 q 和 p 的公共祖先，那么 中节点的数组 一定是在 [p, q]区间的。  
 :fa-star: 从上向下去递归遍历，第一次遇到 cur节点是数值在[p, q]区间中，那么cur就是 p和q的 **_最近公共祖先_** 。

#### 235. 二叉搜索树的最近公共祖先
> 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。  
> 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”


# 19. 二叉搜索树中的插入操作
 :fa-star: 只要遍历二叉搜索树，找到空节点 插入元素就可以了。

#### 701、二叉搜索树中的插入操作
> 给定二叉搜索树（BST）的根节点 root 和要插入树中的值 value ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 任意有效的结果 。

 
# 20. 删除二叉搜索树中的节点
 :fa-star: 搜索树的节点删除要比节点增加复杂的多。有以下五种情况：
>  **_第一种情况_** ：没找到删除的节点，遍历到空节点直接返回了  
> 找到删除的节点:  
>  **_第二种情况_** ：左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点  
>  **_第三种情况_** ：删除节点的左孩子为空，右孩子不为空，删除节点，右孩子补位，返回右孩子为根节点  
>  **_第四种情况_** ：删除节点的右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点  
>  **_第五种情况_** ：左右孩子节点都不为空，则将删除节点的左子树头结点（左孩子）放到删除节点的右子树的最左面节点的左孩子上，返回删除节点右孩子为新的根节点。  

#### 450、删除二叉搜索树中的节点
> 给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。一般来说，删除节点可分为两个步骤：首先找到需要删除的节点；如果找到了，删除它。
 

# 21. 修剪二叉搜索树
 :fa-star: 如果root(当前节点)的元素大于high的，那么应该递归左子树，并返回左子树符合条件的头结点。反之同理。  
 :fa-star: 要遍历整棵树，做修改，有返回值，更方便，可以通过递归函数的返回值来移除节点。

#### 669、修剪二叉搜索树
> 给你二叉搜索树的根节点 root ，同时给定最小边界low 和最大边界 high。通过修剪二叉搜索树，使得所有节点的值在[low, high]中。修剪树 不应该 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在 唯一的答案 。所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。


# 22. 将有序数组转换为二叉搜索树
 :fa-star: 数组构造二叉树，构成平衡树是自然而然的事情，因为大家默认都是从数组中间位置取值作为节点元素，一般不会随机取。所以想构成不平衡的二叉树是自找麻烦。  
 :fa-star: 本质就是寻找分割点，分割点作为当前节点，然后递归左区间和右区间。 _分割点就是数组中间位置的节点_ 。  
 :fa-star: 删除二叉树节点，增加二叉树节点，都是用递归函数的返回值来完成，这样是比较方便的。

#### 108. 将有序数组转换为二叉搜索树
> 给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。


# 23. 把二叉搜索树转换为累加树
 :fa-star: 换一个角度来看，这就是一个有序数组[2, 5, 13]，求从后到前的累加数组。  
 :fa-star: 从树中可以看出累加的顺序是右中左，所以我们需要反中序遍历这个二叉树，然后顺序累加就可以了。

#### 538. 把二叉搜索树转换为累加树
> 给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。  
> 提醒一下，二叉搜索树满足下列约束条件：  
> 节点的左子树仅包含键 小于 节点键的节点。  
> 节点的右子树仅包含键 大于 节点键的节点。  
> 左右子树也必须是二叉搜索树。  



