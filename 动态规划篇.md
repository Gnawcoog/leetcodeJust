# 动态规划理论基础
- 简称DP，如果某一问题有很多重叠子问题，使用动态规划是最有效的。

- 动态规划问题拆解为如下五步曲:
> 1.确定dp数组（dp table）以及下标的含义  
> 2.确定递推公式  
> 3.p数组如何初始化  
> 4.确定遍历顺序  
> 5.举例推导dp数组  



#### 509. 斐波那契数

- 斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：  
F(0) = 0，F(1) = 1  
F(n) = F(n - 1) + F(n - 2)，其中 n > 1  
给定 n ，请计算 F(n) 。

- 动规五部曲:

```c++
// 1.确定dp数组以及下标的含义
dp[i]的定义为：第i个数的斐波那契数值是dp[i]

// 2.确定递推公式
状态转移方程 dp[i] = dp[i - 1] + dp[i - 2]

// 3.dp数组如何初始化
dp[0] = 0;
dp[1] = 1;

// 4.确定遍历顺序
dp[i]依赖 dp[i - 1] 和 dp[i - 2]，遍历顺序一定是从前到后

// 5.举例推导dp数组

```

#### 70. 爬楼梯
- 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

- 动规五部曲：

```c++
// 1.确定dp数组以及下标的含义
dp[i]： 爬到第i层楼梯，有dp[i]种方法

// 2.确定递推公式
dp[i] = dp[i - 1] + dp[i - 2]

// 3.dp数组如何初始化
dp[1] = 1;
dp[2] = 2;

// 4.确定遍历顺序
从前向后

// 举例推导dp数组

```

#### 746. 使用最小花费爬楼梯
- 给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。请你计算并返回达到楼梯顶部的最低花费。

- 动规五部曲：

```c++
// 1.确定dp数组以及下标的含义
dp[i]的定义：到达第i台阶所花费的最少费用为dp[i]。

// 2.确定递推公式
dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);

// 3.dp数组如何初始化
dp[0] = 0，dp[1] = 0;

// 4.确定遍历顺序
从前向后

// 5.举例推导dp数组

```

#### 62.不同路径
- 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。问总共有多少条不同的路径？

- 动规五部曲：

```c++
// 1.确定dp数组以及下标的含义
dp[i][j] ：表示从（0 ，0）出发，到(i, j) 有dp[i][j]条不同的路径。

// 2.确定递推公式
dp[i][j] = dp[i - 1][j] + dp[i][j - 1]，因为dp[i][j]只有这两个方向过来。

// 3.dp数组如何初始化
//横向或竖向每次移动一个
for (int i = 0; i < m; i++) dp[i][0] = 1;
for (int j = 0; j < n; j++) dp[0][j] = 1;

// 4.确定遍历顺序
从左到右一层一层遍历

// 5.举例推导dp数组

```


#### 63. 不同路径II
- 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？网格中的障碍物和空位置分别用 1 和 0 来表示。

- 有障碍的话，其实就是 **标记对应的dp table（dp数组）保持初始值(0)** 就可以了。

- 动规五部曲：

```c++
// 1.确定dp数组以及下标的含义
dp[i][j] ：表示从（0 ，0）出发，到(i, j) 有dp[i][j]条不同的路径。

// 2.确定递推公式
//(i, j)如果就是障碍的话应该就保持初始状态（初始状态为0）。当(i, j)没有障碍的时候，再推导dp[i][j]

if (obstacleGrid[i][j] == 0) { 
    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
}

// 3.dp数组如何初始化
//在横向或竖向移动时，障碍处及之后无法到达，故为0

vector<vector<int>> dp(m, vector<int>(n, 0));
for (int i = 0; i < m && obstacleGrid[i][0] == 0; i++) dp[i][0] = 1;
for (int j = 0; j < n && obstacleGrid[0][j] == 0; j++) dp[0][j] = 1;

// 4.确定遍历顺序
//从左到右一层一层遍历

for (int i = 1; i < m; i++) {
    for (int j = 1; j < n; j++) {
        if (obstacleGrid[i][j] == 1) continue;
        dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
    }
}

// 5.举例推导dp数组
```


#### 343.整数拆分
- 给定一个正整数 n ，将其拆分为 k 个 正整数 的和（ k >= 2 ），并使这些整数的乘积最大化。返回 你可以获得的最大乘积 。

- 动规五部曲：

```c++
// 1.确定dp数组以及下标的含义
dp[i]：分拆数字i，可以得到的最大乘积为dp[i]。

// 2.确定递推公式
dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));

// 3.dp数组如何初始化
dp[2] = 1;

// 4.确定遍历顺序
从前向后
for (int i = 3; i <= n ; i++) {
    for (int j = 1; j < i - 1; j++) {
        dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));
    }
}

// 举例推导dp数组

```


#### 96.不同的二叉搜索树
- 给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。

- 动规五部曲：

```c++
// 1.确定dp数组以及下标的含义
dp[i]：1到i为节点组成的二叉搜索树的个数为dp[i]。

// 2.确定递推公式
//dp[i] += dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量]

dp[i] += dp[j - 1] * dp[i - j];  // j-1 为j为头结点左子树节点数量，i-j 为以j为头结点右子树节点数量

// 3.dp数组如何初始化
dp[0] = 1;

// 4.确定遍历顺序
//遍历i里面每一个数作为头结点的状态，用j来遍历。
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= i; j++) {
        dp[i] += dp[j - 1] * dp[i - j];
    }
}

// 举例推导dp数组
```


# 01背包理论基础
- 有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。

- 动规五部曲（二维dp数组）： 

```c++
// 1.确定dp数组以及下标的含义
//dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。

// 2.确定递推公式
dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);

// 3.dp数组如何初始化
//如果把dp数组预先初始化为0了，这一步就可以省略
for (int j = 0 ; j < weight[0]; j++) { 
    dp[0][j] = 0;
}
// 正序遍历
for (int j = weight[0]; j <= bagweight; j++) {
    dp[0][j] = value[0];
}

// 4. 确定遍历顺序
//两个遍历的维度：物品与背包重量。先遍历物品更好理解
// weight数组的大小 就是物品个数
for(int i = 1; i < weight.size(); i++) { // 遍历物品
    for(int j = 0; j <= bagweight; j++) { // 遍历背包容量
        if (j < weight[i]) dp[i][j] = dp[i - 1][j];
        else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);

    }
}

// 5.举例推导dp数组
```

- 动规五部曲（一维滚动数组）：

```c++
// 1. 确定dp数组的含义
在一维dp数组中，dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]。

// 2. 一维dp数组的递推公式
//dp[j]可以通过dp[j - weight[i]]推导出来，dp[j - weight[i]]表示容量为j - weight[i]的背包所背的最大价值。
//dp[j - weight[i]] + value[i] 表示 容量为 j - 物品i重量 的背包 加上 物品i的价值。（也就是容量为j的背包，放入物品i了之后的价值即：dp[j]）
//两种情况取最大
dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);

// 3. 一维dp数组如何初始化
容量为j的背包，所背的物品价值可以最大为dp[j]，那么dp[0]就应该是0

// 4. 一维dp数组遍历顺序
for(int i = 0; i < weight.size(); i++) { // 遍历物品
    for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);

    }
}

// 5. 举例推导dp数组
```

#### 416.分割等和子集
- 给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

- 动规五部曲：

```c++
// 1. 确定dp数组以及下标的含义
dp[j]表示 背包总容量（所能装的总重量）是j，放进物品后，背的最大重量为dp[j]。

// 2. 确定递推公式
dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);

// 3. dp数组如何初始化
//从dp[j]的定义来看，首先dp[0]一定是0。
//如果题目给的价值都是正整数那么非0下标都初始化为0就可以了，如果题目给的价值有负数，那么非0下标就要初始化为负无穷。

// 4. 确定遍历顺序
//如果使用一维dp数组，物品遍历的for循环放在外层，遍历背包的for循环放在内层，且内层for循环倒序遍历！

for(int i = 0; i < nums.size(); i++) {
    for(int j = target; j >= nums[i]; j--) { // 每一个元素一定是不可重复放入，所以从大到小遍历
        dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);
    }
}

// 5. 举例推导数组
```


#### 1049. 最后一块石头的重量II
- 有一堆石头，用整数数组 stones 表示。其中 stones[i] 表示第 i 块石头的重量。每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x <= y。那么粉碎的可能结果如下：如果 x == y，那么两块石头都会被完全粉碎；
如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。
最后，最多只会剩下一块 石头。返回此石头 最小的可能重量 。如果没有石头剩下，就返回 0。

- 动规五部曲：

```c++
// 1. 确定dp数组以及下标的含义
dp[j]表示容量（这里说容量更形象，其实就是重量）为j的背包，最多可以背最大重量为dp[j]。

// 2. 确定递推公式
dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);

// 3. dp数组如何初始化
//dp[j]中的j表示容量，那么最大容量（重量）是多少呢，就是所有石头的重量和。
//因为重量都不会是负数，所以dp[j]都初始化为0就可以了。
vector<int> dp(15001, 0);

// 4. 确定遍历顺序
如果使用一维dp数组，物品遍历的for循环放在外层，遍历背包的for循环放在内层，且内层for循环倒序遍历！

for (int i = 0; i < stones.size(); i++) { // 遍历物品
    for (int j = target; j >= stones[i]; j--) { // 遍历背包
        dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);
    }
}

// 5. 举例推导数组
//分成两堆石头，一堆石头的总重量是dp[target]，另一堆就是sum - dp[target]。在计算target的时候，target = sum / 2 因为是向下取整，所以sum - dp[target] 一定是大于等于dp[target]的。那么相撞之后剩下的最小石头重量就是 (sum - dp[target]) - dp[target]。
```

#### 494. 目标和
- 给你一个非负整数数组 nums 和一个整数 target 。向数组中的每个整数前添加 '+' 或 '-' ，然后串联起所有整数，可以构造一个 表达式 ：例如，nums = [2, 1] ，可以在 2 之前添加 '+' ，在 1 之前添加 '-' ，然后串联起来得到表达式 "+2-1" 。
返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。

-  left - (sum - left) = target 推导出 left = (target + sum)/2 。此时问题就是在集合nums中找出和为left的组合。

- 动规五部曲：


```c++
// 1. 确定dp数组以及下标的含义
dp[j] 表示：填满j（包括j）这么大容积的包，有dp[j]种方法

// 2. 确定递推公式
//只要搞到nums[i]，凑成dp[j]就有dp[j - nums[i]] 种方法。
//所以求组合类问题的公式，都是类似这种：
dp[j] += dp[j - nums[i]]

// 3. dp数组如何初始化
从递推公式可以看出，在初始化的时候dp[0] 一定要初始化为1

// 4. 确定遍历顺序
//对于01背包问题一维dp的遍历，nums放在外循环，target在内循环，且内循环倒序。

// 5. 举例推导数组
```


#### 474.一和零
- 给你一个二进制字符串数组 strs 和两个整数 m 和 n 。请你找出并返回 strs 的最大子集的长度，该子集中 最多 有 m 个 0 和 n 个 1 。如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。 

- 动规五部曲：

```c++
// 1. 确定dp数组以及下标的含义
dp[i][j]：最多有i个0和j个1的strs的最大子集的大小为dp[i][j]。

// 2.确定递推公式
//dp[i][j] 可以由前一个strs里的字符串推导出来，strs里的字符串有zeroNum个0，oneNum个1。
dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1);


// 3. dp数组如何初始化
//因为物品价值不会是负数，初始为0，保证递推的时候dp[i][j]不会被初始值覆盖。

// 4. 确定遍历顺序
//外层for循环遍历物品，内层for循环遍历背包容量且从后向前遍历！物品就是strs里的字符串，背包容量就是题目描述中的m和n。

for (string str : strs) { // 遍历物品
    int oneNum = 0, zeroNum = 0;
    for (char c : str) {
        if (c == '0') zeroNum++;
        else oneNum++;
    }
    for (int i = m; i >= zeroNum; i--) { // 遍历背包容量且从后向前遍历！
        for (int j = n; j >= oneNum; j--) {
            dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1);
        }
    }
}

// 5. 举例推导数组
```


# 完全背包理论基础
- 有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品都有无限个（也就是可以放入背包多次），求解将哪些物品装入背包里物品价值总和最大。

- 01背包的核心代码

```c++
for(int i = 0; i < weight.size(); i++) { // 遍历物品
    for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
    }
}
```

- 01背包内嵌的循环是从大到小遍历，为了保证每个物品仅被添加一次。而完全背包的物品是可以添加多次的，所以要从小到大去遍历，即：

```c++
// 先遍历物品，再遍历背包
for(int i = 0; i < weight.size(); i++) { // 遍历物品
    for(int j = weight[i]; j <= bagWeight ; j++) { // 遍历背包容量
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);

    }
}
```

- 二维dp数组的两个for遍历的先后循序是可以颠倒的，一维dp数组的两个for循环先后循序一定是先遍历物品，再遍历背包容量。在完全背包中，对于一维dp数组来说，其实两个for循环嵌套顺序是无所谓的！

```c++
// 先遍历背包，再遍历物品
for(int j = 0; j <= bagWeight; j++) { // 遍历背包容量
    for(int i = 0; i < weight.size(); i++) { // 遍历物品
        if (j - weight[i] >= 0) dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
    }
    cout << endl;
}
```


#### 518. 零钱兑换II
- 给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。假设每一种面额的硬币有无限个。 题目数据保证结果符合 32 位带符号整数。

- 纯完全背包是凑成背包最大价值是多少，而本题是要求凑成总金额的物品组合个数！组合不强调元素之间的顺序，排列强调元素之间的顺序。 

- 动规五部曲：

```c++
// 1. 确定dp数组以及下标的含义
dp[j]：凑成总金额j的货币组合数为dp[j]

// 2. 确定递推公式
//求装满背包有几种方法，公式都是：dp[j] += dp[j - nums[i]];
//dp[j] 就是所有的dp[j - coins[i]]（考虑coins[i]的情况）相加。
dp[j] += dp[j - coins[i]];

// 3. dp数组如何初始化
首先dp[0]一定要为1，dp[0] = 1是 递归公式的基础。如果dp[0] = 0 的话，后面所有推导出来的值都是0了。

// 4.确定遍历顺序
//外层for循环遍历物品（钱币），内层for遍历背包（金钱总额）的情况计算的是组合数！
//把两个for交换顺序，dp[j]里算出来的就是排列数！

for (int j = 0; j <= amount; j++) { // 遍历背包容量
    for (int i = 0; i < coins.size(); i++) { // 遍历物品
        if (j - coins[i] >= 0) dp[j] += dp[j - coins[i]];
    }
}

// 5. 举例推导数组
```


#### 377. 组合总和IV
- 给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。题目数据保证答案符合 32 位整数范围。

- 本题题目描述说是求组合，但又说是可以元素相同顺序不同的组合算两个组合，其实就是求排列！

- 动规五部曲：

```c++
// 1. 确定dp数组以及下标的含义
dp[i]: 凑成目标正整数为i的排列个数为dp[i]

// 2. 确定递推公式
//dp[i]（考虑nums[j]）可以由 dp[i - nums[j]]（不考虑nums[j]） 推导出来。因为只要得到nums[j]，排列个数dp[i - nums[j]]，就是dp[i]的一部分。
求装满背包有几种方法，递推公式一般都是dp[i] += dp[i - nums[j]];

// 3. 确定遍历顺序
//因为递推公式dp[i] += dp[i - nums[j]]的缘故，dp[0]要初始化为1，这样递归其他dp[i]的时候才会有数值基础。
dp[0] = 1;

// 4. 确定遍历顺序
//如果求组合数就是外层for循环遍历物品，内层for遍历背包。如果求排列数就是外层for遍历背包，内层for循环遍历物品。
//最终遍历顺序：target（背包）放在外循环，将nums（物品）放在内循环，内循环从前到后遍历。

// 5.举例推导数组
```


#### 322. 零钱兑换
- 给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。你可以认为每种硬币的数量是无限的。

- 动规五部曲：

```c++
// 1. 确定dp数组以及下标的含义
dp[j]：凑足总额为j所需钱币的最少个数为dp[j]

// 2. 确定递推公式
//凑足总额为j - coins[i]的最少个数为dp[j - coins[i]]，那么只需要加上一个钱币coins[i]即dp[j - coins[i]] + 1就是dp[j]（考虑coins[i]）
//所以dp[j] 要取所有 dp[j - coins[i]] + 1 中最小的。

dp[j] = min(dp[j - coins[i]] + 1, dp[j]);

// 3. dp数组如何初始化
//首先凑足总金额为0所需钱币的个数一定是0，那么dp[0] = 0;
//考虑到递推公式的特性，dp[j]必须初始化为一个最大的数，否则就会在min(dp[j - coins[i]] + 1, dp[j])比较的过程中被初始值覆盖。

vector<int> dp(amount + 1, INT_MAX);
dp[0] = 0;

// 4. 确定遍历顺序
//本题求钱币最小个数，那么钱币有顺序和没有顺序都可以，都不影响钱币的最小个数。
//遍历顺序为：coins（物品）放在外循环，target（背包）在内循环。且内循环正序。

// 5. 举例推导数组
```


#### 完全平方数
- 给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。

- 动规五部曲：

```c++
// 1. 确定dp数组（dp table）以及下标的含义
dp[j]：和为j的完全平方数的最少数量为dp[j]

// 2. 确定递推公式
//dp[j] 可以由dp[j - i * i]推出， dp[j - i * i] + 1 便可以凑成dp[j]。
//此时我们要选择最小的dp[j]，所以递推公式：dp[j] = min(dp[j - i * i] + 1, dp[j]);

// 3. dp数组如何初始化
//dp[0]表示 和为0的完全平方数的最小数量，那么dp[0]一定是0。
//从递归公式dp[j] = min(dp[j - i * i] + 1, dp[j]);中可以看出每次dp[j]都要选最小的，所以非0下标的dp[j]一定要初始为最大值，这样dp[j]在递推的时候才不会被初始值覆盖。

vector<int> dp(n + 1, INT_MAX);
dp[0] = 0;
for (int i = 0; i <= n; i++) { // 遍历背包
    for (int j = 1; j * j <= i; j++) { // 遍历物品
        dp[i] = min(dp[i - j * j] + 1, dp[i]);
    }
}

// 5. 举例推导dp数组
```


#### 139. 单词拆分
- 给你一个字符串 s 和一个字符串列表 wordDict 作为字典。请你判断是否可以利用字典中出现的单词拼接出 s 。注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。

- 动规五部曲：

```c++
// 1. 确定dp数组以及下标的含义
dp[i] : 字符串长度为i的话，dp[i]为true，表示可以拆分为一个或多个在字典中出现的单词。

// 2. 确定递推公式
//如果确定dp[j] 是true，且 [j, i] 这个区间的子串出现在字典里，那么dp[i]一定是true。（j < i ）。
//所以递推公式是 if([j, i] 这个区间的子串出现在字典里 && dp[j]是true) 那么 dp[i] = true。

// 3. dp数组如何初始化
//从递推公式中可以看出，dp[i] 的状态依靠 dp[j]是否为true，那么dp[0]就是递推的根基，dp[0]一定要为true，否则递推下去后面都都是false了。

// 4. 确定遍历顺序
//本题求的是排列数，先遍历背包，再遍历物品。

// 5. 举例推导数组
```



# 多重背包理论基础
- 有N种物品和一个容量为V 的背包。第i种物品最多有Mi件可用，每件耗费的空间是Ci ，价值是Wi 。求解将哪些物品装入背包可使这些物品的耗费的空间 总和不超过背包容量，且价值总和最大。

- 每件物品最多有Mi件可用，把Mi件摊开，其实就是一个01背包问题了。

- 多重背包在面试中基本不会出现，力扣上也没有对应的题目。


#### 198. 打家劫舍
- 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额

- 动规五部曲：

```c++
// 1. 确定dp数组（dp table）以及下标的含义
dp[i]：考虑下标i（包括i）以内的房屋，最多可以偷窃的金额为dp[i]。

// 2. 确定递推公式
//决定dp[i]的因素就是第i房间偷还是不偷。
//如果偷第i房间，那么dp[i] = dp[i - 2] + nums[i]
//如果不偷第i房间，那么dp[i] = dp[i - 1]，即考 虑i-1房，（注意这里是考虑）

dp[i]取最大值，即dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);

// 3. dp数组如何初始化
//递推公式的基础就是dp[0] 和 dp[1]
//从dp[i]的定义上来讲，dp[0] 一定是 nums[0]，dp[1]就是nums[0]和nums[1]的最大值;

vector<int> dp(nums.size());
dp[0] = nums[0];
dp[1] = max(nums[0], nums[1]);

// 4. 确定遍历顺序
dp[i] 是根据dp[i - 2] 和 dp[i - 1] 推导出来的，那么一定是从前到后遍历！

for (int i = 2; i < nums.size(); i++) {
    dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);
}

// 5. 举例推导dp数组
```


#### 213. 打家劫舍II
- 你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。

- 对于一个数组，成环的话主要有如下三种情况：
> 考虑不包含首尾元素
> 考虑包含首元素，不包含尾元素
> 考虑包含尾元素，不包含首元素


#### 337. 打家劫舍III
- 小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 root 。除了 root 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 两个直接相连的房子在同一天晚上被打劫 ，房屋将自动报警。给定二叉树的 root 。返回 在不触动警报的情况下 ，小偷能够盗取的最高金额 。

- 递归三部曲and动规五部曲：

```c++
// 1. 确定递归函数的参数和返回值
//这里需要求一个节点偷与不偷的两个状态所得到的金钱，那么返回值就是一个长度为2的数组。返回数组就是dp数组。

vector<int> robTree(TreeNode* cur) {

//dp数组（dp table）以及下标的含义：下标为0记录不偷该节点所得到的的最大金钱，下标为1记录偷该节点所得到的的最大金钱。

// 2. 确定终止条件
//在遍历的过程中，如果遇到空节点的话，很明显，无论偷还是不偷都是0，所以就返回

if (cur == NULL) return vector<int>{0, 0};

// 3. 确定遍历顺序
首先明确的是使用后序遍历。 因为要通过递归函数的返回值来做下一步计算。

// 下标0：不偷，下标1：偷
vector<int> left = robTree(cur->left); // 左
vector<int> right = robTree(cur->right); // 右

// 4. 确定单层递归的逻辑
//如果是偷当前节点，那么左右孩子就不能偷;
//如果不偷当前节点，那么左右孩子就可以偷，至于到底偷不偷一定是选一个最大的;
//最后当前节点的状态就是{val2, val1}; 即：{不偷当前节点得到的最大金钱，偷当前节点得到的最大金钱}

vector<int> left = robTree(cur->left); // 左
vector<int> right = robTree(cur->right); // 右
// 偷cur
int val1 = cur->val + left[0] + right[0];
// 不偷cur
int val2 = max(left[0], left[1]) + max(right[0], right[1]);
return {val2, val1};

// 5. 举例推导DP数组
```


#### 121. 买卖股票的最佳时机
- 给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。

- 动规五部曲：

```c++
// 1. 确定dp数组（dp table）以及下标的含义
//dp[i][0] 表示第i天持有股票所得最多现金
//dp[i][1] 表示第i天不持有股票所得最多现金


// 2. 确定递推公式
//如果第i天持有股票即dp[i][0]， 那么可以由两个状态推出来
//第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：dp[i - 1][0]
//第i天买入股票，所得现金就是买入今天的股票后所得现金即：-prices[i]
//dp[i][0]应该选所得现金最大的

dp[i][0] = max(dp[i - 1][0], -prices[i]);

//如果第i天不持有股票即dp[i][1]， 也可以由两个状态推出来
//第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即：dp[i - 1][1]
//第i天卖出股票，所得现金就是按照今天股票价格卖出后所得现金即：prices[i] + dp[i - 1][0]
//dp[i][1]取最大的

dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0]);

// 3. 确定遍历顺序
//要从dp[0][0]和dp[0][1]推导出来。
//dp[0][0]表示第0天持有股票，此时的持有股票就一定是买入股票了，因为不可能有前一天推出来，所以dp[0][0] -= prices[0];
//dp[0][1]表示第0天不持有股票，不持有股票那么现金就是0，所以dp[0][1] = 0;

// 4. 确定遍历顺序
//从递推公式可以看出dp[i]都是由dp[i - 1]推导出来的，那么一定是从前向后遍历。

// 5. 举例推导dp数组
```


#### 122. 买股票的最佳时机II
- 给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。返回 你能获得的 最大 利润 。

- 本题的股票可以买卖多次！ 所以买入股票的时候，可能会有之前买卖的利润即：dp[i - 1][1]，所以dp[i - 1][1] - prices[i]。


#### 123. 买卖股票的最佳时机III
- 给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

- 动规五部曲：

```c++
// 1. 确定dp数组以及下标的含义
//一天一共就有五个状态：没有操作 （其实我们也可以不设置这个状态）、第一次持有股票、第一次不持有股票、第二次持有股票、第二次不持有股票
//dp[i][j]中 i表示第i天，j为 [0 - 4] 五个状态，dp[i][j]表示第i天状态j所剩最大现金。

// 2. 确定递推公式
//达到dp[i][1]状态，有两个具体操作：
//操作一：第i天买入股票了，那么dp[i][1] = dp[i-1][0] - prices[i]
//操作二：第i天没有操作，而是沿用前一天买入的状态，即：dp[i][1] = dp[i - 1][1]

dp[i][1] = max(dp[i-1][0] - prices[i], dp[i - 1][1]);

//同理

dp[i][2] = max(dp[i - 1][1] + prices[i], dp[i - 1][2]);
dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i]);
dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i]);

// 3. dp数组如何初始化
//第0天没有操作，这个最容易想到，就是0，即：dp[0][0] = 0;
//第0天做第一次买入的操作，dp[0][1] = -prices[0];
//第0天做第一次卖出的操作，dp[0][2] = 0;
//第0天第二次买入操作，dp[0][3] = -prices[0];
//同理第二次卖出初始化dp[0][4] = 0;


// 4. 确定遍历顺序
//从前向后遍历，因为dp[i]，依靠dp[i - 1]的数值。


// 5. 举例推导数组
```


#### 188. 买卖股票的最佳时机IV
- 给你一个整数数组 prices 和一个整数 k ，其中 prices[i] 是某支给定的股票在第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。也就是说，你最多可以买 k 次，卖 k 次。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

- 题目要求是至多有K笔交易，那么j的范围就定义为 2 * k + 1 就可以了。


#### 309. 买卖股票的最佳时机含冷冻期
- 给定一个整数数组prices，其中第  prices[i] 表示第 i 天的股票价格 。​设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

- 动规五部曲：

```c++
// 1. 确定dp数组以及下标的含义
dp[i][j]，第i天状态为j，所剩的最多现金为dp[i][j]。

//具体可以区分出如下四个状态：
//状态一：持有股票状态
//不持有股票状态，这里就有两种卖出股票状态：
//状态二：保持卖出股票的状态（两天前就卖出了股票，度过一天冷冻期。或者是前一天就是卖出股票状态，一直没操作）
//状态三：今天卖出股票
//状态四：今天为冷冻期状态，但冷冻期状态不可持续，只有一天！

// 2. 确定递推公式

dp[i][0] = max(dp[i - 1][0], max(dp[i - 1][3], dp[i - 1][1]) - prices[i]);
dp[i][1] = max(dp[i - 1][1], dp[i - 1][3]);
dp[i][2] = dp[i - 1][0] + prices[i];
dp[i][3] = dp[i - 1][2];

// 3. dp数组如何初始化
//初始为0

// 4. 确定遍历顺序
dp[i] 依赖于 dp[i-1]，所以是从前向后遍历。

// 5. 举例推导数组
```


#### 714. 买卖股票的最佳时机含手续费
- 给定一个整数数组 prices，其中 prices[i]表示第 i 天的股票价格 ；整数 fee 代表了交易股票的手续费用。你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。返回获得利润的最大值。注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。

- 本题只需要在计算卖出操作的时候减去手续费就可以了。


#### 300. 最长递增子序列
- 给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

- 动规五部曲：

```c++
// 1. dp[i]的定义
dp[i]表示i之前包括i的以nums[i]结尾的最长递增子序列的长度

// 2. 状态转移方程
//位置i的最长升序子序列等于j从0到i-1各个位置的最长升序子序列 + 1 的最大值。

if (nums[i] > nums[j]) dp[i] = max(dp[i], dp[j] + 1);

// 3. dp[i]的初始化
//每一个i，对应的dp[i]（即最长递增子序列）起始大小至少都是1

// 4. 确定遍历顺序
//dp[i] 是有0到i-1各个位置的最长递增子序列 推导而来，那么遍历i一定是从前向后遍历。
//j其实就是遍历0到i-1，舒顺序无所谓，从前向后遍历。

for (int i = 1; i < nums.size(); i++) {
    for (int j = 0; j < i; j++) {
        if (nums[i] > nums[j]) dp[i] = max(dp[i], dp[j] + 1);
    }
    if (dp[i] > result) result = dp[i]; // 取长的子序列
}

// 5.举例推导dp数组
```


#### 718. 最长重复子数组
- 给两个整数数组 nums1 和 nums2 ，返回 两个数组中 公共的 、长度最长的子数组的长度 。

- 动规五部曲：

```c++
// 1. 确定dp数组（dp table）以及下标的含义
dp[i][j] ：以下标i - 1为结尾的A，和以下标j - 1为结尾的B，最长重复子数组长度为dp[i][j]。

// 2. 确定递推公式
//根据dp[i][j]的定义，dp[i][j]的状态只能由dp[i - 1][j - 1]推导出来。
//即当A[i - 1] 和B[j - 1]相等的时候，dp[i][j] = dp[i - 1][j - 1] + 1;

// 3. dp数组如何初始化
//根据dp[i][j]的定义，dp[i][0] 和dp[0][j]其实都是没有意义的！
//但dp[i][0] 和dp[0][j]要初始值，初始化为0。

// 4. 确定遍历顺序
//外层for循环遍历A，内层for循环遍历B。

for (int i = 1; i <= nums1.size(); i++) {
    for (int j = 1; j <= nums2.size(); j++) {
        if (nums1[i - 1] == nums2[j - 1]) {
            dp[i][j] = dp[i - 1][j - 1] + 1;
        }
        if (dp[i][j] > result) result = dp[i][j];
    }
}

// 5. 举例推导数组
```


#### 1143. 最长公共子序列
- 给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。

- 动规五部曲：

```c++
// 1. 确定dp数组（dp table）以及下标的含义
dp[i][j]：长度为[0, i - 1]的字符串text1与长度为[0, j - 1]的字符串text2的最长公共子序列为dp[i][j]

// 2. 确定递推公式
//如果text1[i - 1] 与 text2[j - 1]相同，那么找到了一个公共元素，所以dp[i][j] = dp[i - 1][j - 1] + 1;
//如果不相同，那就看看text1[0, i - 2]与text2[0, j - 1]的最长公共子序列 和 text1[0, i - 1]与text2[0, j - 2]的最长公共子序列，取最大的。

if (text1[i - 1] == text2[j - 1]) {
    dp[i][j] = dp[i - 1][j - 1] + 1;
} else {
    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
}

// 3. dp数组如何初始化
//test1[0, i-1]和空串的最长公共子序列自然是0，所以dp[i][0] = 0;同理dp[0][j]也是0。
//其他下标都是随着递推公式逐步覆盖，初始为多少都可以，那么就统一初始为0。

vector<vector<int>> dp(text1.size() + 1, vector<int>(text2.size() + 1, 0));

// 4. 确定遍历顺序
//从递推公式，可以看出，有三个方向可以推出dp[i][j]。所以要从前向后，从上到下来遍历这个矩阵。

// 5. 举例推导数组
```


#### 1035. 不相交的线
- 在两条独立的水平线上按给定的顺序写下 nums1 和 nums2 中的整数。现在，可以绘制一些连接两个数字 nums1[i] 和 nums2[j] 的直线，这些直线需要同时满足满足：nums1[i] == nums2[j]，且绘制的直线不与任何其他连线（非水平线）相交。请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。以这种方法绘制线条，并返回可以绘制的最大连线数。

- 本题就是求最长公共子序列的长度。


#### 53. 最大子序和
- 给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。子数组 是数组中的一个连续部分。

- 动规五部曲：

```c++
// 1. 确定dp数组（dp table）以及下标的含义
dp[i]：包括下标i（以nums[i]为结尾）的最大连续子序列和为dp[i]。

// 2. 确定递推公式
//dp[i]只有两个方向可以推出来：
//dp[i - 1] + nums[i]，即：nums[i]加入当前连续子序列和
//nums[i]，即：从头开始计算当前连续子序列和
dp[i] = max(dp[i - 1] + nums[i], nums[i]);

// 3. dp数组如何初始化
//从递推公式可以看出来dp[i]是依赖于dp[i - 1]的状态，dp[0]就是递推公式的基础。
//根据dp[i]的定义，很明显dp[0]应为nums[0]即dp[0] = nums[0]。

// 4. 确定遍历顺序
//递推公式中dp[i]依赖于dp[i - 1]的状态，需要从前向后遍历。

// 5. 举例推导dp数组
```


#### 392.判断子序列
- 给定字符串 s 和 t ，判断 s 是否为 t 的子序列。

- 动规五部曲：

```c++
// 1. 确定dp数组（dp table）以及下标的含义
//dp[i][j] 表示以下标i-1为结尾的字符串s，和以下标j-1为结尾的字符串t，相同子序列的长度为dp[i][j]。

// 2. 确定递推公式
//if (s[i - 1] == t[j - 1])，那么dp[i][j] = dp[i - 1][j - 1] + 1；因为找到了一个相同的字符，相同子序列长度自然要在dp[i-1][j-1]的基础上加1；
//if (s[i - 1] != t[j - 1])，此时相当于t要删除元素，t如果把当前元素t[j - 1]删除，那么dp[i][j] 的数值就是 看s[i - 1]与 t[j - 2]的比较结果了，即：dp[i][j] = dp[i][j - 1];

// 3. dp数组如何初始化
//dp[i][0] 表示以下标i-1为结尾的字符串，与空字符串的相同子序列长度，所以为0；dp[0][j]同理。

vector<vector<int>> dp(s.size() + 1, vector<int>(t.size() + 1, 0));

// 4. 确定遍历顺序
//同理从递推公式可以看出dp[i][j]都是依赖于dp[i - 1][j - 1] 和 dp[i][j - 1]，那么遍历顺序也应该是从上到下，从左到右

// 5. 举例推导数组
```


#### 115. 不同的子序列
- 给你两个字符串 s 和 t ，统计并返回在 s 的 子序列 中 t 出现的个数。题目数据保证答案符合 32 位带符号整数范围。

- 动规五部曲：

```c++
// 1. 确定dp数组（dp table）以及下标的含义
//dp[i][j]：以i-1为结尾的s子序列中出现以j-1为结尾的t的个数为dp[i][j]。

// 2. 确定递推公式
//这一类问题，基本是要分析两种情况：s[i - 1] 与 t[j - 1]相等；s[i - 1] 与 t[j - 1] 不相等
//当s[i - 1] 与 t[j - 1]相等时，dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];
//当s[i - 1] 与 t[j - 1]不相等时，dp[i][j]只有一部分组成，dp[i][j] = dp[i - 1][j];

// 3. dp数组如何初始化
//从递推公式可以看出dp[i][j] 是从上方和左上方推导而来，那么 dp[i][0] 和dp[0][j]是一定要初始化的。
//dp[i][0] 表示：以i-1为结尾的s可以随便删除元素，出现空字符串的个数。
//dp[0][j]：空字符串s可以随便删除元素，出现以j-1为结尾的字符串t的个数。

vector<vector<long long>> dp(s.size() + 1, vector<long long>(t.size() + 1));
for (int i = 0; i <= s.size(); i++) dp[i][0] = 1;
for (int j = 1; j <= t.size(); j++) dp[0][j] = 0; 

// 4. 确定遍历顺序
//从上到下，从左到右。

for (int i = 1; i <= s.size(); i++) {
    for (int j = 1; j <= t.size(); j++) {
        if (s[i - 1] == t[j - 1]) {
            dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];
        } else {
            dp[i][j] = dp[i - 1][j];
        }
    }
}

// 5. 举例推导数组
```


#### 583. 两个字符串的删除操作
- 给定两个单词 word1 和 word2 ，返回使得 word1 和  word2 相同所需的最小步数。每步 可以删除任意一个字符串中的一个字符。

- 动规五部曲：

```c++
// 1. 确定dp数组（dp table）以及下标的含义
//dp[i][j]：以i-1为结尾的字符串word1，和以j-1位结尾的字符串word2，想要达到相等，所需要删除元素的最少次数。

// 2. 确定递推公式
//当word1[i - 1] 与 word2[j - 1]相同的时候，dp[i][j] = dp[i - 1][j - 1];
//当word1[i - 1] 与 word2[j - 1]不相同的时候，有三种情况：
//情况一：删word1[i - 1]，最少操作次数为dp[i - 1][j] + 1
//情况二：删word2[j - 1]，最少操作次数为dp[i][j - 1] + 1
//情况三：同时删word1[i - 1]和word2[j - 1]，操作的最少次数为dp[i - 1][j - 1] + 2
//因为 dp[i][j - 1] + 1 = dp[i - 1][j - 1] + 2，所以递推公式可简化为：dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1);

// 3. dp数组如何初始化
//从递推公式中，可以看出来，dp[i][0] 和 dp[0][j]是一定要初始化的。
//dp[i][0]：word2为空字符串，以i-1为结尾的字符串word1要删除多少个元素，才能和word2相同呢，很明显dp[i][0] = i。dp[0][j]同理。

vector<vector<int>> dp(word1.size() + 1, vector<int>(word2.size() + 1));
for (int i = 0; i <= word1.size(); i++) dp[i][0] = i;
for (int j = 0; j <= word2.size(); j++) dp[0][j] = j;

// 4. 确定遍历顺序
从上到下，从左到右。

// 5. 举例推导数组
```


#### 72. 编辑距离
- 给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数 。你可以对一个单词进行如下三种操作：插入一个字符、删除一个字符、替换一个字符。
 
- 动规五部曲：

```c++
//1. 确定dp数组（dp table）以及下标的含义
//dp[i][j] 表示以下标i-1为结尾的字符串word1，和以下标j-1为结尾的字符串word2，最近编辑距离为dp[i][j]。

// 2. 确定递推公式
//4种情况

if (word1[i - 1] == word2[j - 1])
    不操作
if (word1[i - 1] != word2[j - 1])
    增
    删
    换

//if (word1[i - 1] == word2[j - 1]) 那么说明不用任何编辑，即dp[i][j] = dp[i - 1][j - 1];

//if (word1[i - 1] != word2[j - 1])，此时就需要编辑了，如何编辑呢？
//操作一：word1删除一个元素，那么就是以下标i - 2为结尾的word1 与 j-1为结尾的word2的最近编辑距离 再加上一个操作。即 dp[i][j] = dp[i - 1][j] + 1;

//操作二：word2删除一个元素，那么就是以下标i - 1为结尾的word1 与 j-2为结尾的word2的最近编辑距离 再加上一个操作。即 dp[i][j] = dp[i][j - 1] + 1;

//操作三：替换元素，word1替换word1[i - 1]，使其与word2[j - 1]相同，此时不用增删加元素。所以 dp[i][j] = dp[i - 1][j - 1] + 1;

//当 if (word1[i - 1] != word2[j - 1]) 时取最小的。

if (word1[i - 1] == word2[j - 1]) {
    dp[i][j] = dp[i - 1][j - 1];
}
else {
    dp[i][j] = min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1;
}

// 3. dp数组如何初始化
//dp[i][0] ：以下标i-1为结尾的字符串word1，和空字符串word2，最近编辑距离为dp[i][0]。那么dp[i][0]就应该是i，对word1里的元素全部做删除操作，即：dp[i][0] = i;同理dp[0][j] = j;

for (int i = 0; i <= word1.size(); i++) dp[i][0] = i;
for (int j = 0; j <= word2.size(); j++) dp[0][j] = j;

// 4. 确定遍历顺序
//从左到右从上到下去遍历。

for (int i = 1; i <= word1.size(); i++) {
    for (int j = 1; j <= word2.size(); j++) {
        if (word1[i - 1] == word2[j - 1]) {
            dp[i][j] = dp[i - 1][j - 1];
        }
        else {
            dp[i][j] = min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1;
        }
    }
}

// 5. 举例推导数组
```


#### 647. 回文子串
- 给你一个字符串 s ，请你统计并返回这个字符串中 回文子串 的数目。回文字符串 是正着读和倒过来读一样的字符串。子字符串 是字符串中的由连续字符组成的一个序列。具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。

- 动规五部曲：

```c++
// 1.确定dp数组以及下标的含义
//布尔类型的dp[i][j]：表示区间范围[i,j] （注意是左闭右闭）的子串是否是回文子串。

// 2. 确定递推公式
//当s[i]与s[j]不相等，dp[i][j]一定是false。
//当s[i]与s[j]相等时，有如下三种情况
//情况一：下标i 与 j相同，同一个字符例如a，当然是回文子串
//情况二：下标i 与 j相差为1，例如aa，也是回文子串
//情况三：下标：i 与 j相差大于1的时候，看dp[i + 1][j - 1]是否为true。

if (s[i] == s[j]) {
    if (j - i <= 1) { // 情况一 和 情况二
        result++; // 统计回文子串的数量
        dp[i][j] = true;
    } else if (dp[i + 1][j - 1]) { // 情况三
        result++;
        dp[i][j] = true;
    }
}
//result就是统计回文子串的数量。

// 3. dp数组如何初始化
//dp[i][j]初始化为false。

// 4. 确定遍历顺序
//要从下到上，从左到右遍历，这样保证dp[i + 1][j - 1]都是经过计算的。

for (int i = s.size() - 1; i >= 0; i--) {  // 注意遍历顺序
    for (int j = i; j < s.size(); j++) {
        if (s[i] == s[j]) {
            if (j - i <= 1) { // 情况一 和 情况二
                result++;
                dp[i][j] = true;
            } else if (dp[i + 1][j - 1]) { // 情况三
                result++;
                dp[i][j] = true;
            }
        }
    }
}
 
// 5. 举例推导数组
```


#### 516. 最长回文子序列
- 给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。

- 动规五部曲：

```c++
// 1. 确定dp数组（dp table）以及下标的含义
dp[i][j]：字符串s在[i, j]范围内最长的回文子序列的长度为dp[i][j]。

// 2. 确定递推公式
//如果s[i]与s[j]相同，那么dp[i][j] = dp[i + 1][j - 1] + 2;
//如果s[i]与s[j]不相同，说明s[i]和s[j]的同时加入 并不能增加[i,j]区间回文子序列的长度，那么分别加入s[i]、s[j]。

//加入s[j]的回文子序列长度为dp[i + 1][j]。
//加入s[i]的回文子序列长度为dp[i][j - 1]。
//dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);

if (s[i] == s[j]) {
    dp[i][j] = dp[i + 1][j - 1] + 2;
} else {
    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);
}

// 3. dp数组如何初始化
//递推公式是计算不到 i 和j相同时候的情况。
//需要手动初始化一下，当i与j相同，那么dp[i][j]一定是等于1的，即：一个字符的回文子序列长度就是1。
//其他情况dp[i][j]初始为0就行。

vector<vector<int>> dp(s.size(), vector<int>(s.size(), 0));
for (int i = 0; i < s.size(); i++) dp[i][i] = 1;

// 4. 确定遍历顺序
//遍历i的时候一定要从下到上遍历，这样才能保证下一行的数据是经过计算的。
//j的话，可以正常从左向右遍历。

for (int i = s.size() - 1; i >= 0; i--) {
    for (int j = i + 1; j < s.size(); j++) {
        if (s[i] == s[j]) {
            dp[i][j] = dp[i + 1][j - 1] + 2;
        } else {
            dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);
        }
    }
}

// 5. 举例推导dp数组
```










